import numpy as np
import unittest
from numba import jit, types, njit, prange#, float16
from numba.types import float16, float64, int8
from numba.core.errors import NumbaTypeError, NumbaValueError
from operator import ixor
from numpy import int64

import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../src')))

from core import GLOBAL_INTEGER, symplectic_inner_product
from util import convert_array_type, toBinary
from galois import GF2

import numpy as np

#@njit() #GOOD, TESTED
def row_reduce(input_pauli):
    """
    Perform row reduction on integers using bitwise operations,
    and remove zero rows from the result.

    Parameters:
        input_pauli (list of ints): The first element is k (an integer),
                             the rest are integers representing rows.

    Returns:
        list of ints: The reduced integers, with k at the zero index,
                      and zero rows removed.
    """
    # Extract k and calculate the number of bits used
    data = input_pauli.copy()
    k = data[0]
    num_bits = 2 * k + 1  # Total bits including the sign bit
    num_bits_without_sign = num_bits - 1  # Exclude the sign bit

    # Extract the integer rows (excluding the zero index)
    int_rows = data[1:]

    # Remove the sign bit (rightmost bit) by shifting right
    for i in range(len(int_rows)):
        int_rows[i] = int_rows[i] >> 1

    n_rows = len(int_rows)
    n_cols = num_bits_without_sign

    pivot_row = 0

    # Forward elimination to get row echelon form

    for col in range(n_cols - 1, -1, -1):  # Start from the most significant bit
        found_pivot = False
        for row in range(pivot_row, n_rows):
            if (int_rows[row] >> col) & 1:
                if row != pivot_row:
                    # Swap rows
                    temp = int_rows[pivot_row]
                    int_rows[pivot_row] = int_rows[row]
                    int_rows[row] = temp
                found_pivot = True
                break
        if not found_pivot:
            continue
        # Eliminate entries below the pivot
        for row in range(pivot_row + 1, n_rows):
            if (int_rows[row] >> col) & 1:
                int_rows[row] ^= int_rows[pivot_row]
        pivot_row += 1
        if pivot_row >= n_rows:
            break

    # Backward substitution to get reduced row echelon form
    for i in range(pivot_row - 1, -1, -1):
        row_val = int_rows[i]
        # Find the pivot column in this row
        for col in range(n_cols - 1, -1, -1):
            if (row_val >> col) & 1:
                pivot_col = col
                break
        else:
            continue  # Skip if the row is zero
        # Eliminate entries above the pivot
        for row in range(i):
            if (int_rows[row] >> pivot_col) & 1:
                int_rows[row] ^= int_rows[i]

    # Remove zero rows and shift left to restore the sign bit position
    reduced_int_rows = []
    for row in int_rows:
        if row != 0:
            reduced_row = row << 1  # Restore sign bit position (set to zero)
            reduced_int_rows.append(reduced_row)

    # Return the data with k at the zero index
    result = np.zeros(len(reduced_int_rows) + 1, dtype=GLOBAL_INTEGER)
    result[0] = k
    result[1:] = reduced_int_rows
    #result.extend(reduced_int_rows)
    return result


# NO NUMBA, BAD
def null_space(A, rcond=None):
    #Conver to a GF2 matrix:
    A = GF2(A)
    return A.null_space().astype(GLOBAL_INTEGER)
    #return Q#.T

@njit() #TESTED, basic
def inner_product(paulis):
    """
    Computes the symplectic inner product matrix of the given paulis.
    
    Given an input [k, sym_1, sym_2, ..., sym_n], the symplectic inner product matrix is computed as
    [[sbf(sym_1, sym_1), sbf(sym_1, sym_2), ..., sbf(sym_1, sym_n)],
     [sbf(sym_2, sym_1), sbf(sym_2, sym_2), ..., sbf(sym_2, sym_n)],
     ...
     [sbf(sym_n, sym_1), sbf(sym_n, sym_2), ..., sbf(sym_n, sym_n)]]
    Conver the resulting binary array to an integer representation, add k at the zero index. here, k is n, the number of sym inputs which should be less than 2n
    Additionally, append a sign bit =0 at the zero index. 
    
    
    Args:
        paulis (list): List containing k at index 0 and the symplectic forms.
        
    Returns:
        numpy.ndarray: Symplectic inner product matrix.
    """
    k = paulis[0]
    sym_forms = paulis[1:]
    n = len(sym_forms)
    ip_matrix = np.zeros((n, n), dtype=np.int8)
    for i in prange(n):
        for j in prange(n):
            ip_matrix[i, j] = symplectic_inner_product(np.array([k,sym_forms[i]]), np.array([k,sym_forms[j]]) )
    return ip_matrix

def radical(paulis, reduced=False):
    """
    Computes the generators of the radical of the group generated by the paulis.
    
    Args:
        paulis (list): List containing k at index 0 and the symplectic forms.
        reduced (bool): If False, reduce the data using the row_reduce function.
        
    Returns:
        GF2 array: Integer array
    """
    if not reduced:
        reduced_pauli = row_reduce(paulis.copy())
    else:
        reduced_pauli = paulis.copy()
    #    paulis.row_reduce().row_space()
    #print('GSG', inner_product(paulis, paulis))
    return null_space(inner_product(reduced_pauli))
    

def centralizer(pauli_input, reduced=False):
    """Returns the centralizer of the input Pauli group. First computes the radical, then takes the kernel of the reduced Pauli input basis ker(P)@P.
    
    
    Args:
        pauli_input (ndarray): List containing k at index 0 and the symplectic forms.
        reduced (bool): If False, reduce the data using the row_reduce function.
    """    
    if not reduced:
        reduced_pauli = row_reduce(pauli_input.copy())
    else:
        reduced_pauli = pauli_input.copy()
    kernel = radical(reduced_pauli, reduced=True)
    kernel = convert_array_type(kernel, int8)
    reduced_pauli = toBinary(reduced_pauli)
    return kernel @ reduced_pauli




#TODO: Check inGroup function